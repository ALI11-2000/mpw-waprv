//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.12-2022/01/27-beta
`include "sp_verilog.vh" //_\SV
   /*
   Copyright 2022 Redwood EDA
   
   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */

//_\source warpv_core.tlv 44
//_\SV
   // Include WARP-V.
   
   // Included URL: "https://raw.githubusercontent.com/ALI11-2000/warp-v/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warp-v.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/tlv_lib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentals_lib.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/cc27801ff64687d54094da698ed28c40351ed288/risc-v_defs.tlv"
                   
   
                   
	module warpv_core( output [31:0] dmem_addra,
                      output [31:0] dmem_addrb,
                      output [31:0] dmem_dina ,
                      output [31:0] dmem_dinb ,
                      output [3:0]  dmem_wea  ,
                      output        dmem_wea0 ,
                      output [3:0]  dmem_web  ,
                      output        dmem_ena  ,
                      output        dmem_enb  ,
                      input  [31:0] dmem_doutb,
                      output [31:0] imem_addr ,
                      input  [31:0] imem_data,
                      input         clk, reset);

`include "warpv_core_gen.v" //_\TLV
   //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3427   // Instantiated from warpv_core.tlv, 122 as: m4+cpu(/top)
      // Generated logic
      // Instantiate the _gen macro for the right ISA. (This approach is required for an m4-defined name.)
      
      //_\source /raw.githubusercontent.com/stevehoover/warpvincludes/cc27801ff64687d54094da698ed28c40351ed288/riscvdefs.tlv 232   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3431 as: m4+m4_gen()
      
         
         // v---------------------
         // Instruction characterization
      
         // M4 ugliness for instruction characterization.
         
         // For each opcode[6:2]
         // (User ISA Manual 2.2, Table 19.1)
         // Associate opcode[6:2] ([1:0] are 2'b11) with mnemonic and instruction type.
         // Instruction type is not in the table, but there seems to be a single instruction type for each of these,
         // so that is mapped here as well.
         // op5(bits, type, mnemonic)
         /*SV_plus*/
            
            
            
            
            
            
            
            
            
            
            
              // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
            
            
            
            
            
            
            
            
              // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
            
            
            
            
            
            
            
            
            
            
            
            
         /*SV_plus*/
            
            
         /*SV_plus*/
            // Instruction characterization.
            // (User ISA Manual 2.2, Table 19.2)
            // instr(type,  // (this is simply verified vs. op5)
            //       |  bit-width,
            //       |  |   extension, 
            //       |  |   |  opcode[6:2],  // (aka op5)
            //       |  |   |  |      func3,   // (if applicable)
            //       |  |   |  |      |    mnemonic)
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            //m4_instr(_, 32, I, 00011, 000, FENCE)
            //m4_instr(_, 32, I, 00011, 001, FENCE_I)
            //m4_instr(_, 32, I, 11100, 000, ECALL_EBREAK)  // Two instructions distinguished by an immediate bit, treated as a single instruction.
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            //m4_instr(R4, 32, B, 01100, 001, 11, CMIX)  // Currently we are excluing ternary BMI's for optimization, although its only a draft
            //m4_instr(R4, 32, B, 01100, 101, 11, CMOV)
            //m4_instr(R4, 32, B, 01100, 001, 10, FSL)
            //m4_instr(R4, 32, B, 01100, 101, 10, FSR)
            //m4_instr(R4, 32, B, 00100, 101, 10, FSRI)
             // single operand instruction are currently using R2-type rather than I-type encoding
            
            
            //m4_instr(R2, 64, B, 01100, 001, 0110000, 00011, BMATFLIP)
            
            
            
            
            
            //m4_instr(R2, 64, B, 01100, 001, 0110000, 10011, CRC32D)
            
            
            
            //m4_instr(R2, 64, B, 01100, 001, 0110000, 11011, CRC32CD)
            
            
            
            
            
            
            
            
            
            
            
            
            
            //m4_instr(R, 64, B, 01100, 011, 0000100, BMATOR)
            //m4_instr(R, 64, B, 01100, 011, 0100100, BMATXOR)
            
            
            
            
            //m4_instr(I, 64, B, 01100, 100, ADDIWU)
            //m4_instr(If, 64, B, 01100, 001, 000010, SLLIUW)
            //m4_instr(R, 64, B, 01110, 000, 0000101, ADDWU)
            //m4_instr(R, 64, B, 01110, 000, 0100101, SUBWU)
            //m4_instr(R, 64, B, 01110, 000, 0000100, ADDUW)
            //m4_instr(R, 64, B, 01110, 000, 0100100, SUBUW)
            //m4_instr(R, 64, B, 01110, 001, 0010000, SLOW)
            //m4_instr(R, 64, B, 01110, 101, 0010000, SROW)
            //m4_instr(R, 64, B, 01110, 001, 0110000, ROLW)
            //m4_instr(R, 64, B, 01110, 101, 0110000, RORW)
            //m4_instr(R, 64, B, 01110, 001, 0100100, SBCLRW)
            //m4_instr(R, 64, B, 01110, 001, 0010100, SBSETW)
            //m4_instr(R, 64, B, 01110, 001, 0110100, SBINVW)
            //m4_instr(R, 64, B, 01110, 101, 0100100, SBEXTW)
            //m4_instr(R, 64, B, 01110, 101, 0010100, GROCW)
            //m4_instr(R, 64, B, 01110, 101, 0110100, GREVW)
            //m4_instr(If, 64, B, 00110, 001, 001000, SLOIW)
            //m4_instr(If, 64, B, 00110, 101, 001000, SROIW)
            //m4_instr(If, 64, B, 00110, 101, 011000, RORIW)
            //m4_instr(If, 64, B, 00110, 001, 010010, SBCLRIW)
            //m4_instr(If, 64, B, 00110, 001, 001010, SBSETIW)
            //m4_instr(If, 64, B, 00110, 001, 011010, SBINVIW)
            //m4_instr(If, 64, B, 00110, 101, 001010, GORCIW)
            //m4_instr(If, 64, B, 00110, 101, 011010, GREVIW)
            //m4_instr(R4, 64, B, 01110, 001, 10, FSLW)
            //m4_instr(R4, 64, B, 01110, 101, 10, FSRW)
            //m4_instr(R4, 64, B, 00110, 101, 10, FSRIW) //rs2 is "imm"
            //m4_instr(R2, 64, B, 00110, 001, 0110000, 00000, CLZW)
            //m4_instr(R2, 64, B, 00110, 001, 0110000, 00001, CTZW)
            //m4_instr(R2, 64, B, 00110, 001, 0110000, 00010, PCNTW)
            //m4_instr(R, 64, B, 01110, 001, 0000101, CLMULW)
            //m4_instr(R, 64, B, 01110, 010, 0000101, CLMULRW)
            //m4_instr(R, 64, B, 01110, 011, 0000101, CLMULHW)
            //m4_instr(R, 64, B, 01110, 001, 0000100, SHFLW)
            //m4_instr(R, 64, B, 01110, 101, 0000100, UNSHFLW)
            //m4_instr(R, 64, B, 01110, 110, 0100100, BDEPW)
            //m4_instr(R, 64, B, 01110, 110, 0000100, BEXTW)
            //m4_instr(R, 64, B, 01110, 100, 0000100, PACKW)
            //m4_instr(R, 64, B, 01110, 100, 0100100, PACKUW)
            //m4_instr(R, 64, B, 01110, 111, 0100100, BFPW)
         // ^---------------------
      //_\end_source
      // Instruction memory and fetch of $raw.
      //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1510   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3433 as: m4+M4_IMEM_MACRO_NAME(M4_PROG_NAME)
         // Instantiate the program. (This approach is required for an m4-defined name.)
         
         //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1338   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1513 as: m4+m4_prog()
         
            // /=====================\
            // | Count to 10 Program |
            // \=====================/
            //
            // Default program for RV32I test
            // Add 1,2,3,...,9 (in that order).
            // Store incremental results in memory locations 0..9. (1, 3, 6, 10, ...)
            //
            // Regs:
            // 1: cnt
            // 2: ten
            // 3: out
            // 4: tmp
            // 5: offset
            // 6: store addr
          
            // Inst #0: ORI,x6,x0,0        //     store_addr = 0
            // Inst #1: ORI,x1,x0,1        //     cnt = 1
            // Inst #2: ORI,x2,x0,1010     //     ten = 10
            // Inst #3: ORI,x3,x0,0        //     out = 0
            // Inst #4: ADD,x3,x1,x3       //  -> out += cnt
            // Inst #5: SW,x6,x3,0         //     store out at store_addr
            // Inst #6: ADDI,x1,x1,1       //     cnt ++
            // Inst #7: ADDI,x6,x6,100     //     store_addr++
            // Inst #8: BLT,x1,x2,1111111110000 //  ^- branch back if cnt < 10
            // Inst #9: LW,x4,x6,111111111100 //     load the final value into tmp
            // Inst #10: BGE,x1,x2,1111111010100 //     TERMINATE by branching to -1
         //_\end_source
         
         // ==============
         // IMem and Fetch
         // ==============
         
         //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1519 as: m4+ifelse(M4_FORMAL, 1,
            
            //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 90 as: m4+ifelse.
               
               //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 90 as: m4+ifelse.
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1564   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__2.
                     //_|fetch
                        //_/instr
                           //_@0
                              //_?$fetch
                                 assign imem_addr = FETCH_Instr_next_pc_a0;
                           //_@1
                              //_?$fetch
                                 assign FETCH_Instr_raw_a1[31:0] = imem_data;
                  //_\end_source
                  
               //_\end_source
            //_\end_source
         //_\end_source
      //_\end_source
   
   
      // /=========\
      // | The CPU |
      // \=========/
   
      //_|fetch
         //_/instr
            
            
            // Provide a longer reset to cover the pipeline depth.
            //_@-1
               assign FETCH_Instr_soft_reset_n1 = (1'b0) || reset;
               assign FETCH_Instr_Cnt_n2[7:0] = FETCH_Instr_soft_reset_n1   ? 8'b0 :       // reset
                            FETCH_Instr_Cnt_n1 == 8'hFF ? 8'hFF :      // max out to avoid wrapping
                                            FETCH_Instr_Cnt_n1 + 8'b1; // increment
               assign FETCH_Instr_reset_n1 = FETCH_Instr_soft_reset_n1 || FETCH_Instr_Cnt_n1 < 10;
            //_@0
               assign FETCH_Instr_fetch_a0 = ! FETCH_Instr_reset_a0 && ! FETCH_Instr_NoFetch_a0;
               // (M4_IMEM_MACRO_NAME instantiation produces ?$fetch$raw.)
            //_@0
               
               // ========
               // Overview
               // ========
               
               // Terminology:
               //
               // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and returning_ld are separate instructions,
               //              and the returning_ld and the instruction it clobbers are one in the same).
               // ISA Instruction: An instruction, as defined by the ISA.
               // Good-Path (vs. Bad-Path): On the proper flow of execution of the program, excluding aborted instructions.
               // Path (of an instruction): The sequence of instructions that led to a particular instruction.
               // Current Path: The sequence of instructions fetched by next-PC logic that are not known to be bad-path.
               // Redirect: Adjust the PC from the predicted next-PC.
               // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
               // Bubbles: The cycles in the redirect shadow.
               // Commit: Results are made visible to subsequent instructions.
               // Abort: Do not commit. All aborts are also redirects and put the instruction on bad path. Non-aborting
               //        redirects do not mark the triggering instruction as bad-path. Aborts mask future redirects on the
               //        aborted instruction.
               // Retire: Commit results of an ISA instruction.
               
               // Control flow:
               //
               // Redirects include (earliest to latest):
               //   o Returning load: (aborting) A returning load clobbers an instruction and takes its slot, resulting in a
               //                     one-cycle redirect to repeat the clobbered instruction.
               //   o Predict-taken branch: A predicted-taken branch must determine the target before it can redirect the PC.
               //                           (This might be followed up by a mispredition.)
               //   o Replay: (aborting) Replay the same instruction (because a source register is pending (awaiting a long-latency/2nd issuing instruction))
               //   o Jump: A jump instruction.
               //   o Mispredicted branch: A branch condition was mispredicted.
               //   o Aborting traps: (aborting) illegal instructions, others?
               //   o Non-aborting traps: misaligned PC target
               
               // ==============
               // Redirect Logic
               // ==============
                               
               // PC logic will redirect the PC for conditions on current-path instructions. PC logic keeps track of which
               // instructions are on the current path with a $GoodPathMask. $GoodPathMask[n] of an instruction indicates
               // whether the instruction n instructions prior to this instruction is on its path.
               //
               //                 $GoodPathMask for Redir'edX => {o,X,o,y,y,y,o,o} == {1,1,1,1,0,0,1,1}
               // Waterfall View: |
               //                 V
               // 0)       oooooooo                  Good-path
               // 1) InstX  ooooooXo  (Non-aborting) Good-path
               // 2)         ooooooxx
               // 3) InstY    ooYyyxxx  (Aborting)
               // 4) InstZ     ooyyxZxx
               // 5) Redir'edY  oyyxxxxx
               // 6) TargetY     ooxxxxxx
               // 7) Redir'edX    oxxxxxxx
               // 8) TargetX       oooooooo          Good-path
               // 9) Not redir'edZ  oooooooo         Good-path
               //
               // Above depicts a waterfall diagram where three triggering redirection conditions X, Y, and Z are detected on three different
               // instructions. A trigger in the 1st depicted stage, M4_NEXT_PC_STAGE, results in a zero-bubble redirect so it would be
               // a condition that is factored directly into the next-PC logic of the triggering instruction, and it would have
               // no impact on the $GoodPathMask.
               //
               // Waveform View:
               //
               //   Inst 0123456789
               //        ---------- /
               // GPM[7]        ooxxxxxxoo
               // GPM[6]       oXxxxxxxoo
               // GPM[5]      oooxZxxxoo
               // GPM[4]     oooyxxxxoo
               // GPM[3]    oooyyxxxoo
               // GPM[2]   oooYyyxxoo
               // GPM[1]  oooooyoxoo
               // GPM[0] oooooooooo
               //          /
               //         Triggers for InstY
               //
               // In the waveform view, the mask shifts up each cycle, as instructions age, and trigger conditions mask instructions
               // in the shadow, down to the redirect target (GPM[0]).
               //
               // Terminology:
               //   Triggering instruction: The instruction on which the condition is detected.
               //   Redirected instruction: The instruction whose next PC is redirected.
               //   Redirection target instruction: The first new-path instruction resulting from the redirection.
               //
               // Above, Y redirects first, though it is for a later instruction than X. The redirections for X and Y are taken
               // because their instructions are on the path of the redirected instructions. Z is not on the path of its
               // potentially-redirected instruction, so no redirection happens.
               //
               // For simultaneous conditions on different instructions, the PC must redirect to the earlier instruction's
               // redirect target, so later-stage redirects take priority in the PC-mux.
               //
               // Aborting redirects result in the aborting instruction being marked as bad-path. Aborted instructions will
               // not commit. Subsequent redirect conditions on aborting instructions are ignored. (For conditions within the
               // same stage, this is accomplished by the PC-mux prioritization.)
               
               
               // Macros are defined elsewhere based on the ordered set of conditions that generate code here.
               
               // Redirect Shadow
               // A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
               // Index 1 is ahead by 1, etc.
               // In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
               //     (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
               // The LSB is fetch-valid. It only exists for m4_prev_instr_valid_through macro.
               assign FETCH_Instr_next_good_path_mask_a0[3+1:0] =
                  // Shift up and mask w/ redirect conditions.
                  {FETCH_Instr_GoodPathMask_a0[3:0]
                   // & terms for each condition (order doesn't matter since masks are the same within a cycle)
                    & ((FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_pred_taken_branch_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_replay_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_indirect_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_pipelined_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{0{1'b1}}, {4{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}),
                   1'b1}; // Shift in 1'b1 (fetch-valid).
               
               assign FETCH_Instr_GoodPathMask_n1[3+1:0] =
                  FETCH_Instr_reset_n1 ? 5'b0 :  // All bad-path (through self) on reset (next mask based on next reset).
                  FETCH_Instr_next_good_path_mask_a0;
               
               //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3571 as: m4+ifelse(M4_FORMAL, 1,
                  
                  
               //_\end_source
               
               
               // A returning load clobbers the instruction.
               // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
               //  it is non-speculative. Both could easily be fixed.)
               assign FETCH_Instr_second_issue_ld_a0 = MEM_Data_valid_ld_a4 && 1'b1;
               assign FETCH_Instr_second_issue_a0 = (FETCH_Instr_second_issue_ld_a0   );
               // Recirculate returning load or the div_mul_result from /orig_inst scope
               
               // This reduces significantly once $ANY acts on subscope.
               //_?$second_issue_ld
                  // This scope holds the original load for a returning load.
                  //_/orig_load_inst
                     assign {FETCH_Instr_OrigLoadInst_addr_a0[1:0], FETCH_Instr_OrigLoadInst_dest_reg_a0[4:0], FETCH_Instr_OrigLoadInst_ld_st_half_a0, FETCH_Instr_OrigLoadInst_ld_st_word_a0, FETCH_Instr_OrigLoadInst_ld_value_a0[31:0], FETCH_Instr_OrigLoadInst_pc_a0[31:2], FETCH_Instr_OrigLoadInst_raw_funct3_a0[2], FETCH_Instr_OrigLoadInst_spec_ld_a0} = {MEM_Data_addr_a4, MEM_Data_dest_reg_a4, MEM_Data_ld_st_half_a4, MEM_Data_ld_st_word_a4, MEM_Data_ld_value_a4, MEM_Data_pc_a4, MEM_Data_raw_funct3_a4, MEM_Data_spec_ld_a4};
                     for (src = 1; src <= 2; src=src+1) begin : L1_FETCH_Instr_OrigLoadInst_Src wire L1_dummy_a0; //_/src
                        assign {L1_dummy_a0} = {L1_MEM_Data_Src[src].L1_dummy_a4}; end
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3599 as: m4+ifelse(M4_EXT_F, 1,
                        
                        
                     //_\end_source
               //_?$second_issue
                  //_/orig_inst
                     // pull values from /orig_load_inst or /hold_inst depending on which second issue
                     assign {FETCH_Instr_OrigInst_dest_reg_a0[4:0], FETCH_Instr_OrigInst_pc_a0[31:2]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_pc_a0} :    {FETCH_Instr_OrigLoadInst_dest_reg_a0, FETCH_Instr_OrigLoadInst_pc_a0};
                     for (src = 1; src <= 2; src=src+1) begin : L1_FETCH_Instr_OrigInst_Src wire L1_dummy_a0; reg  L1_dummy_a1, L1_dummy_a2, L1_dummy_a3; //_/src
                        assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} :    {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0}; end
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3612 as: m4+ifelse(M4_EXT_F, 1,
                        
                        
                     //_\end_source
               // Next PC
               assign FETCH_Instr_pc_inc_a0[31:2] = FETCH_Instr_Pc_a0 + 30'b1;
               // Current parsing does not allow concatenated state on left-hand-side, so, first, a non-state expression.
               assign {FETCH_Instr_next_pc_a0[31:2], FETCH_Instr_next_no_fetch_a0} =
                  FETCH_Instr_reset_a0 ? {30'b0, 1'b0} :
                  // ? : terms for each condition (order does matter)
                  (FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_trap_target_a3, 1'b0} : (FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_trap_target_a3, 1'b0} : (FETCH_Instr_non_pipelined_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_pc_inc_a3, 1'b1} : (FETCH_Instr_indirect_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_indirect_jump_target_a2, 1'b0} : (FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_branch_redir_pc_a2, 1'b0} : (FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_jump_target_a2, 1'b0} : (FETCH_Instr_replay_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_Pc_a1, 1'b0} : (FETCH_Instr_pred_taken_branch_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_branch_target_a1, 1'b0} : (FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0, 1'b1} : (FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0, 1'b0} : 
                             ({FETCH_Instr_pc_inc_a0, 1'b0});
               // Then as state.
               assign FETCH_Instr_Pc_n1[31:2] = FETCH_Instr_next_pc_a0;
               assign FETCH_Instr_NoFetch_n1 = FETCH_Instr_next_no_fetch_a0;
            
            //_@1
   
               // ======
               // DECODE
               // ======
   
               // Decode of the fetched instruction
               assign FETCH_Instr_valid_decode_a1 = FETCH_Instr_fetch_a1;  // Always decode if we fetch.
               assign FETCH_Instr_valid_decode_branch_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_branch_a1;
               // A load that will return later.
               //$split_ld = $spec_ld && 1'b['']M4_INJECT_RETURNING_LD;
               // Instantiate the program. (This approach is required for an m4-defined name.)
               
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1770   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3644 as: m4+m4_decode_macro_name()
                  // TODO: ?$valid_<stage> conditioning should be replaced by use of m4_prev_instr_valid_through(..).
                  //_?$valid_decode
                     // =================================
               
                     // Extract fields of $raw (instruction) into $raw_<field>[x:0].
                     assign {FETCH_Instr_raw_funct7_a1[6:0], FETCH_Instr_raw_rs2_a1[4:0], FETCH_Instr_raw_rs1_a1[4:0], FETCH_Instr_raw_funct3_a1[2:0], FETCH_Instr_raw_rd_a1[4:0], FETCH_Instr_raw_op5_a1[4:0], FETCH_Instr_raw_op2_a1[1:0]} = FETCH_Instr_raw_a1;
                     `BOGUS_USE(FETCH_Instr_raw_op2_a1)  // Delete once it's used.
                     // Extract immediate fields into type-specific signals.
                     // (User ISA Manual 2.2, Fig. 2.4)
                     assign FETCH_Instr_raw_i_imm_a1[31:0] = {{21{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[30:20]};
                     assign FETCH_Instr_raw_s_imm_a1[31:0] = {{21{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[30:25], FETCH_Instr_raw_a1[11:7]};
                     assign FETCH_Instr_raw_b_imm_a1[31:0] = {{20{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[7], FETCH_Instr_raw_a1[30:25], FETCH_Instr_raw_a1[11:8], 1'b0};
                     assign FETCH_Instr_raw_u_imm_a1[31:0] = {FETCH_Instr_raw_a1[31:12], {12{1'b0}}};
                     assign FETCH_Instr_raw_j_imm_a1[31:0] = {{12{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[19:12], FETCH_Instr_raw_a1[20], FETCH_Instr_raw_a1[30:21], 1'b0};
                     // Extract other type/instruction-specific fields.
                     assign FETCH_Instr_raw_shamt_a1[6:0] = FETCH_Instr_raw_a1[26:20];
                     assign FETCH_Instr_raw_aq_a1 = FETCH_Instr_raw_a1[26];
                     assign FETCH_Instr_raw_rl_a1 = FETCH_Instr_raw_a1[25];
                     assign FETCH_Instr_raw_rs3_a1[4:0] = FETCH_Instr_raw_a1[31:27];
                     assign FETCH_Instr_raw_rm_a1[2:0] = FETCH_Instr_raw_funct3_a1;
                     `BOGUS_USE(FETCH_Instr_raw_shamt_a1 FETCH_Instr_raw_aq_a1 FETCH_Instr_raw_rl_a1 FETCH_Instr_raw_rs3_a1 FETCH_Instr_raw_rm_a1)  // Avoid "unused" messages. Remove these as they become used.
               
                     // Instruction type decode
                     /*SV_plus*/
                        assign FETCH_Instr_is_i_type_a1 = (((0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001) | (1 << 5'b11100)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_r_type_a1 = (((0 | (1 << 5'b01011) | (1 << 5'b01100) | (1 << 5'b01110) | (1 << 5'b10100)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_r2_type_a1 = (((0) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_r4_type_a1 = (((0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_s_type_a1 = (((0 | (1 << 5'b01000) | (1 << 5'b01001)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_b_type_a1 = (((0 | (1 << 5'b11000)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_j_type_a1 = (((0 | (1 << 5'b11011)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_u_type_a1 = (((0 | (1 << 5'b00101) | (1 << 5'b01101)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is___type_a1 = (((0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; 
               
                     // Instruction decode.
                     //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1747   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1798 as: m4+riscv_decode_expr()
                        assign FETCH_Instr_is_lui_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01101;
                        assign FETCH_Instr_is_auipc_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00101;
                        assign FETCH_Instr_is_jal_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11011;
                        assign FETCH_Instr_is_jalr_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11001 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                        assign FETCH_Instr_is_beq_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                        assign FETCH_Instr_is_bne_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                        assign FETCH_Instr_is_blt_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                        assign FETCH_Instr_is_bge_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                        assign FETCH_Instr_is_bltu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                        assign FETCH_Instr_is_bgeu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                        assign FETCH_Instr_is_lb_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                        assign FETCH_Instr_is_lh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                        assign FETCH_Instr_is_lw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                        assign FETCH_Instr_is_lbu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                        assign FETCH_Instr_is_lhu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                        assign FETCH_Instr_is_sb_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                        assign FETCH_Instr_is_sh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                        assign FETCH_Instr_is_sw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                        assign FETCH_Instr_is_addi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                        assign FETCH_Instr_is_slti_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                        assign FETCH_Instr_is_sltiu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                        assign FETCH_Instr_is_xori_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                        assign FETCH_Instr_is_ori_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                        assign FETCH_Instr_is_andi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                        assign FETCH_Instr_is_slli_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b001 && FETCH_Instr_raw_funct7_a1[6:1] == 6'b000000;
                        assign FETCH_Instr_is_srli_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:1] == 6'b000000;
                        assign FETCH_Instr_is_srai_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:1] == 6'b010000;
                        assign FETCH_Instr_is_add_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b000 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_sub_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b000 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0100000;
                        assign FETCH_Instr_is_sll_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b001 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_slt_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b010 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_sltu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b011 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_xor_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b100 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_srl_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_sra_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0100000;
                        assign FETCH_Instr_is_or_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b110 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_and_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b111 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                        assign FETCH_Instr_is_csrrw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                        assign FETCH_Instr_is_csrrs_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                        assign FETCH_Instr_is_csrrc_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                        assign FETCH_Instr_is_csrrwi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                        assign FETCH_Instr_is_csrrsi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                        assign FETCH_Instr_is_csrrci_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                        
                     //_\end_source
                     
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1800 as: m4+ifelse(M4_EXT_M, 1,
                        //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1807   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__9.
                           assign FETCH_Instr_div_mul_a1 = 1'b0;
                           assign FETCH_Instr_multype_instr_a1 = 1'b0;
                           `BOGUS_USE(FETCH_Instr_multype_instr_a1)
                        //_\end_source
                        
                     //_\end_source
               
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1813 as: m4+ifelse(M4_EXT_F, 1,
                        
                        
                     //_\end_source
                     
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1871 as: m4+ifelse(M4_EXT_B, 1,
                        
                        
                     //_\end_source
               
                     assign FETCH_Instr_is_srli_srai_instr_a1 = FETCH_Instr_is_srli_instr_a1 || FETCH_Instr_is_srai_instr_a1;
                     // Some I-type instructions have a funct7 field rather than immediate bits, so these must factor into the illegal instruction expression explicitly.
                     assign FETCH_Instr_illegal_itype_with_funct7_a1 = ( FETCH_Instr_is_srli_srai_instr_a1  ) && | {FETCH_Instr_raw_funct7_a1[6], FETCH_Instr_raw_funct7_a1[4:0]};
                     assign FETCH_Instr_illegal_a1 = (FETCH_Instr_illegal_itype_with_funct7_a1 && ! FETCH_Instr_is_lui_instr_a1 && ! FETCH_Instr_is_auipc_instr_a1 && ! FETCH_Instr_is_jal_instr_a1 && ! FETCH_Instr_is_jalr_instr_a1 && ! FETCH_Instr_is_beq_instr_a1 && ! FETCH_Instr_is_bne_instr_a1 && ! FETCH_Instr_is_blt_instr_a1 && ! FETCH_Instr_is_bge_instr_a1 && ! FETCH_Instr_is_bltu_instr_a1 && ! FETCH_Instr_is_bgeu_instr_a1 && ! FETCH_Instr_is_lb_instr_a1 && ! FETCH_Instr_is_lh_instr_a1 && ! FETCH_Instr_is_lw_instr_a1 && ! FETCH_Instr_is_lbu_instr_a1 && ! FETCH_Instr_is_lhu_instr_a1 && ! FETCH_Instr_is_sb_instr_a1 && ! FETCH_Instr_is_sh_instr_a1 && ! FETCH_Instr_is_sw_instr_a1 && ! FETCH_Instr_is_addi_instr_a1 && ! FETCH_Instr_is_slti_instr_a1 && ! FETCH_Instr_is_sltiu_instr_a1 && ! FETCH_Instr_is_xori_instr_a1 && ! FETCH_Instr_is_ori_instr_a1 && ! FETCH_Instr_is_andi_instr_a1 && ! FETCH_Instr_is_slli_instr_a1 && ! FETCH_Instr_is_srli_instr_a1 && ! FETCH_Instr_is_srai_instr_a1 && ! FETCH_Instr_is_add_instr_a1 && ! FETCH_Instr_is_sub_instr_a1 && ! FETCH_Instr_is_sll_instr_a1 && ! FETCH_Instr_is_slt_instr_a1 && ! FETCH_Instr_is_sltu_instr_a1 && ! FETCH_Instr_is_xor_instr_a1 && ! FETCH_Instr_is_srl_instr_a1 && ! FETCH_Instr_is_sra_instr_a1 && ! FETCH_Instr_is_or_instr_a1 && ! FETCH_Instr_is_and_instr_a1 && ! FETCH_Instr_is_csrrw_instr_a1 && ! FETCH_Instr_is_csrrs_instr_a1 && ! FETCH_Instr_is_csrrc_instr_a1 && ! FETCH_Instr_is_csrrwi_instr_a1 && ! FETCH_Instr_is_csrrsi_instr_a1 && ! FETCH_Instr_is_csrrci_instr_a1) ||
                                (FETCH_Instr_raw_a1[1:0] != 2'b11); // All legal instructions have opcode[1:0] == 2'b11. We ignore these bits in decode logic.
                     assign FETCH_Instr_conditional_branch_a1 = FETCH_Instr_is_b_type_a1;
                  assign FETCH_Instr_jump_a1 = FETCH_Instr_is_jal_instr_a1;  // "Jump" in RISC-V means unconditional. (JALR is a separate redirect condition.)
                  assign FETCH_Instr_branch_a1 = FETCH_Instr_is_b_type_a1;
                  assign FETCH_Instr_indirect_jump_a1 = FETCH_Instr_is_jalr_instr_a1;
                  //_?$valid_decode
                     assign FETCH_Instr_ld_a1 = FETCH_Instr_raw_a1[6:3] == 4'b0;
                     assign FETCH_Instr_st_a1 = FETCH_Instr_is_s_type_a1;
                     assign FETCH_Instr_ld_st_a1 = FETCH_Instr_ld_a1 || FETCH_Instr_st_a1;
                     assign FETCH_Instr_ld_st_word_a1 = FETCH_Instr_ld_st_a1 && (FETCH_Instr_raw_funct3_a1[1] == 1'b1);
                     assign FETCH_Instr_ld_st_half_a1 = FETCH_Instr_ld_st_a1 && (FETCH_Instr_raw_funct3_a1[1:0] == 2'b01);
                     //$ld_st_byte = $ld_st && ($raw_funct3[1:0] == 2'b00);
                     `BOGUS_USE(FETCH_Instr_is___type_a1 FETCH_Instr_is_u_type_a1)
               
                     // Output signals.
                     for (src = 1; src <= 2; src=src+1) begin : L1_FETCH_Instr_Src wire L1_is_reg_a1; reg  L1_is_reg_a2, L1_is_reg_a3; wire [4:0] L1_reg_a1; reg  [4:0] L1_reg_a2, L1_reg_a3; //_/src
                        // Reg valid for this source, based on instruction type.
                        assign L1_is_reg_a1 =
                            
                            (FETCH_Instr_is_r_type_a1 || FETCH_Instr_is_r4_type_a1 || (FETCH_Instr_is_i_type_a1 && (src == 1)) || FETCH_Instr_is_r2_type_a1 || FETCH_Instr_is_s_type_a1 || FETCH_Instr_is_b_type_a1);
                        assign L1_reg_a1[4:0] = (src == 1) ? FETCH_Instr_raw_rs1_a1[4:0] : FETCH_Instr_raw_rs2_a1[4:0]; end
                        
                  // Condition signals must not themselves be conditioned (currently).
                  assign FETCH_Instr_dest_reg_a1[4:0] = 
                                                   
                                                   FETCH_Instr_second_issue_ld_a1 ? FETCH_Instr_OrigInst_dest_reg_a1 : FETCH_Instr_raw_rd_a1[4:0];
                  assign FETCH_Instr_dest_reg_valid_a1 =  ((FETCH_Instr_valid_decode_a1 && ! FETCH_Instr_is_s_type_a1 && ! FETCH_Instr_is_b_type_a1) || FETCH_Instr_second_issue_a1) &&
                                    | FETCH_Instr_dest_reg_a1;   // r0 not valid.  TODO: Huh? What about FP? No formal failure?
                  
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1919 as: m4+ifelse(M4_EXT_F, 1,
                     
                     
                  //_\end_source
                  
                  // Actually load.
                  assign FETCH_Instr_spec_ld_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_ld_a1;
                  
                  // CSR decode.
                  assign FETCH_Instr_is_csr_write_a1 = FETCH_Instr_is_csrrw_instr_a1 || FETCH_Instr_is_csrrwi_instr_a1;
                  assign FETCH_Instr_is_csr_set_a1   = FETCH_Instr_is_csrrs_instr_a1 || FETCH_Instr_is_csrrsi_instr_a1;
                  assign FETCH_Instr_is_csr_clear_a1 = FETCH_Instr_is_csrrc_instr_a1 || FETCH_Instr_is_csrrci_instr_a1;
                  assign FETCH_Instr_is_csr_instr_a1 = FETCH_Instr_is_csr_write_a1 ||
                                  FETCH_Instr_is_csr_set_a1   ||
                                  FETCH_Instr_is_csr_clear_a1;
                  assign FETCH_Instr_valid_csr_a1 = 1'b0 || FETCH_Instr_is_csr_cycle_a1 || FETCH_Instr_is_csr_cycleh_a1 || FETCH_Instr_is_csr_time_a1 || FETCH_Instr_is_csr_timeh_a1 || FETCH_Instr_is_csr_instret_a1 || FETCH_Instr_is_csr_instreth_a1;
                  assign FETCH_Instr_csr_trap_a1 = FETCH_Instr_is_csr_instr_a1 && ! FETCH_Instr_valid_csr_a1;
               //_\end_source
            // Instantiate the program. (This approach is required for an m4-defined name.)
            
            //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3105   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3647 as: m4+m4_branch_pred_macro_name()
               //_@1
                  //_?$branch
                     assign FETCH_Instr_pred_taken_a1 = FETCH_Instr_BranchState_a3[1];
               //_@2
                  assign FETCH_Instr_branch_or_reset_a2 = (FETCH_Instr_branch_a2 && FETCH_Instr_commit_a2) || FETCH_Instr_reset_a2;
                  //_?$branch_or_reset
                     assign FETCH_Instr_BranchState_a1[1:0] =
                        FETCH_Instr_reset_a2 ? 2'b01 :
                        FETCH_Instr_taken_a2 ? (FETCH_Instr_BranchState_a2 == 2'b11 ? FETCH_Instr_BranchState_a2[1:0] : FETCH_Instr_BranchState_a2 + 2'b1) :
                                 (FETCH_Instr_BranchState_a2 == 2'b00 ? FETCH_Instr_BranchState_a2[1:0] : FETCH_Instr_BranchState_a2 - 2'b1);
            //_\end_source
            
            //_@1
               // Pending value to write to dest reg. Loads (not replaced by returning ld) write pending.
               assign FETCH_Instr_reg_wr_pending_a1 = FETCH_Instr_ld_a1 && ! FETCH_Instr_second_issue_a1 && 1'b1;
               `BOGUS_USE(FETCH_Instr_reg_wr_pending_a1)  // Not used if no bypass and no pending.
               
               // ======
               // Reg Rd
               // ======
               
               // Obtain source register values and pending bit for source registers.
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3771   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3659 as: m4+operands( , /src, 2:1)
                  // Obtain source register values and pending bit for int or fp source registers. Bypass up to 3
                  // stages.
                  // It is not necessary to bypass pending, as we could delay the replay, but we implement
                  // bypass for performance.
                  // Pending has an additional read for the dest register as we need to replay for write-after-write
                  // hazard as well as write-after-read. To replay for dest write with the same timing, we must also
                  // bypass the dest reg's pending bit.
                  assign FETCH_Instr_bypass_avail1_a1 = FETCH_Instr_valid_dest_reg_valid_a2 && (FETCH_Instr_GoodPathMask_a1[1] || FETCH_Instr_second_issue_a2);
                  assign FETCH_Instr_bypass_avail2_a1 = FETCH_Instr_valid_dest_reg_valid_a3 && (FETCH_Instr_GoodPathMask_a1[2] || FETCH_Instr_second_issue_a3);
                  
                  for (src = 1; src <= 2; src=src+1) begin : L1b_FETCH_Instr_Src wire L1_is_reg_condition_a1; reg  L1_is_reg_condition_a2; wire L1_pending_a1; wire [31:0] L1_reg_value_a1; reg  [31:0] L1_reg_value_a2, L1_reg_value_a3; wire [31:0] L1_rf_value_a1; //_/src
                     assign L1_is_reg_condition_a1 = L1_FETCH_Instr_Src[src].L1_is_reg_a1 && FETCH_Instr_valid_decode_a1;  // Note: $is_reg can be set for RISC-V sr0.
                     //_?$is_reg_condition
                        assign L1_rf_value_a1[31:0] =
                             FETCH_Instr_Regs_value_a3[L1_FETCH_Instr_Src[src].L1_reg_a1];
                        /* verilator lint_off WIDTH */  // TODO: Disabling WIDTH to work around what we think is https://github.com/verilator/verilator/issues/1613, when --fmtPackAll is in use.
                        assign {L1_reg_value_a1[31:0], L1_pending_a1} =
                           (L1_FETCH_Instr_Src[src].L1_reg_a1 == 5'b0) ? {32'b0, 1'b0} :  // Read r0 as 0 (not pending).
                           // Bypass stages. Both register and pending are bypassed.
                           // Bypassed registers must be from instructions that are good-path as of this instruction or are 2nd issuing.
                           (FETCH_Instr_bypass_avail1_a1 && (FETCH_Instr_dest_reg_a2 == L1_FETCH_Instr_Src[src].L1_reg_a1)) ? {FETCH_Instr_rslt_a2, FETCH_Instr_reg_wr_pending_a2} :
                           (FETCH_Instr_bypass_avail2_a1 && (FETCH_Instr_dest_reg_a3 == L1_FETCH_Instr_Src[src].L1_reg_a1)) ? {FETCH_Instr_rslt_a3, FETCH_Instr_reg_wr_pending_a3} :
                           
                           {L1_rf_value_a1, FETCH_Instr_Regs_pending_a3[L1_FETCH_Instr_Src[src].L1_reg_a1]};
                        /* verilator lint_on WIDTH */
                     // Replay if source register is pending.
                     assign FETCH_Instr_Src_replay_a1[src] = L1_is_reg_condition_a1 && L1_pending_a1; end
                  
                  // Also replay for pending dest reg to keep writes in order. Bypass dest reg pending to support this.
                  assign FETCH_Instr_is_dest_condition_a1 = FETCH_Instr_dest_reg_valid_a1 && FETCH_Instr_valid_decode_a1;
                  //_?$is_dest_condition
                     assign FETCH_Instr_dest_pending_a1 =
                        (FETCH_Instr_dest_reg_a1 == 5'b0) ? 1'b0 :  // Read r0 as 0 (not pending). Not actually necessary, but it cuts off read of non-existent rs0, which might be an issue for formal verif tools.
                        // Bypass stages.
                        (FETCH_Instr_bypass_avail1_a1 && (FETCH_Instr_dest_reg_a2 == FETCH_Instr_dest_reg_a1)) ? FETCH_Instr_reg_wr_pending_a2 :
                        (FETCH_Instr_bypass_avail2_a1 && (FETCH_Instr_dest_reg_a3 == FETCH_Instr_dest_reg_a1)) ? FETCH_Instr_reg_wr_pending_a3 :
                        
                        FETCH_Instr_Regs_pending_a3[FETCH_Instr_dest_reg_a1];
                  // Combine replay conditions for pending source or dest registers.
                  assign FETCH_Instr_pending_replay_a1 = | FETCH_Instr_Src_replay_a1 || (FETCH_Instr_is_dest_condition_a1 && FETCH_Instr_dest_pending_a1);
               //_\end_source
               for (src = 1; src <= 2; src=src+1) begin : L1c_FETCH_Instr_Src wire L1_dummy_a1; reg  L1_dummy_a2, L1_dummy_a3; //_/src
                  assign L1_dummy_a1 = 1'b0; end  // Dummy signal to pull through $ANY expressions when not building verification harness (since SandPiper currently complains about empty $ANY).
               
               //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3663 as: m4+ifelse(M4_EXT_F, 1,
                  
                  
               //_\end_source
               assign FETCH_Instr_replay_a1 = (FETCH_Instr_pending_replay_a1 );
            
            // =======
            // Execute
            // =======
            
            // Instantiate the program. (This approach is required for an m4-defined name.)
            
            //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1954   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3681 as: m4+m4_exe_macro_name(@M4_EXECUTE_STAGE, @M4_RESULT_STAGE)
               // if M_EXT is enabled, this handles the stalling logic
               
            
               // if F_EXT is enabled, this handles the stalling logic
               
            
               // if B_EXT is enabled, this handles the stalling logic
               
               
               //_@1
                  //_?$valid_decode_branch
                     assign FETCH_Instr_branch_target_a1[31:2] = FETCH_Instr_Pc_a1[31:2] + FETCH_Instr_raw_b_imm_a1[31:2];
                     assign FETCH_Instr_misaligned_pc_a1 = | FETCH_Instr_raw_b_imm_a1[1:0];
                  //_?$jump  // (JAL, not JALR)
                     assign FETCH_Instr_jump_target_a1[31:2] = FETCH_Instr_Pc_a1[31:2] + FETCH_Instr_raw_j_imm_a1[31:2];
                     assign FETCH_Instr_misaligned_jump_target_a1 = FETCH_Instr_raw_j_imm_a1[1];
               //_@2
                  // Execution.
                  assign FETCH_Instr_valid_exe_a2 = FETCH_Instr_valid_decode_a2; // Execute if we decoded.
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1974 as: m4+ifelse(M4_EXT_M, 1,
                     
                     
                  //_\end_source
             
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1994 as: m4+ifelse(M4_EXT_F, 1,
                     
                     
                  //_\end_source
                  
                  
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2018 as: m4+ifelse(M4_EXT_B, 1,
                     
                     
                  //_\end_source
            
                  // hold_inst scope is not needed when long latency instructions are disabled
                  
                  // Compute results for each instruction, independent of decode (power-hungry, but fast).
                  //_?$valid_exe
                     assign FETCH_Instr_equal_a2 = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 == L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                  //_?$branch
                     assign FETCH_Instr_taken_a2 =
                        FETCH_Instr_is_j_type_a2 ||
                        (FETCH_Instr_is_beq_instr_a2 && FETCH_Instr_equal_a2) ||
                        (FETCH_Instr_is_bne_instr_a2 && ! FETCH_Instr_equal_a2) ||
                        ((FETCH_Instr_is_blt_instr_a2 || FETCH_Instr_is_bltu_instr_a2 || FETCH_Instr_is_bge_instr_a2 || FETCH_Instr_is_bgeu_instr_a2) &&
                         ((FETCH_Instr_is_bge_instr_a2 || FETCH_Instr_is_bgeu_instr_a2) ^
                          (({(FETCH_Instr_is_blt_instr_a2 ^ L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]), L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31-1:0]} <
                            {(FETCH_Instr_is_blt_instr_a2 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]), L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31-1:0]}
                           ) ^ ((L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] != L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]) & FETCH_Instr_is_bge_instr_a2)
                          )
                         )
                        );
                  //_?$indirect_jump  // (JALR)
                     assign FETCH_Instr_indirect_jump_full_target_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + FETCH_Instr_raw_i_imm_a2;
                     assign FETCH_Instr_indirect_jump_target_a2[31:2] = FETCH_Instr_indirect_jump_full_target_a2[31:2];
                     assign FETCH_Instr_misaligned_indirect_jump_target_a2 = FETCH_Instr_indirect_jump_full_target_a2[1];
                  //_?$valid_exe
                     // Compute each individual instruction result, combined per-instruction by a macro.
                     // TODO: Could provide some macro magic to specify combined instructions w/ a single result and mux select.
                     //       This would reduce code below and probably improve implementation.
                     
                     assign FETCH_Instr_lui_rslt_a2[31:0]   = {FETCH_Instr_raw_u_imm_a2[31:12], 12'b0};
                     assign FETCH_Instr_auipc_rslt_a2[31:0] = {FETCH_Instr_Pc_a2, 2'b0} + FETCH_Instr_raw_u_imm_a2;
                     assign FETCH_Instr_jal_rslt_a2[31:0]   = {FETCH_Instr_Pc_a2, 2'b0} + 4;
                     assign FETCH_Instr_jalr_rslt_a2[31:0]  = {FETCH_Instr_Pc_a2, 2'b0} + 4;
                     // Load instructions. If returning ld is enabled, load instructions write no meaningful result, so we use zeros.
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2123 as: m4+ifelse(M4_INJECT_RETURNING_LD, 1,
                        //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 2124   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__17.
                           assign FETCH_Instr_lb_rslt_a2[31:0]    = 32'b0;
                           assign FETCH_Instr_lh_rslt_a2[31:0]    = 32'b0;
                           assign FETCH_Instr_lw_rslt_a2[31:0]    = 32'b0;
                           assign FETCH_Instr_lbu_rslt_a2[31:0]   = 32'b0;
                           assign FETCH_Instr_lhu_rslt_a2[31:0]   = 32'b0;
                           
                           
                           
                        //_\end_source
                        
                     //_\end_source
                     assign FETCH_Instr_addi_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + FETCH_Instr_raw_i_imm_a2;  // TODO: This has its own adder; could share w/ add/sub.
                     assign FETCH_Instr_xori_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 ^ FETCH_Instr_raw_i_imm_a2;
                     assign FETCH_Instr_ori_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 | FETCH_Instr_raw_i_imm_a2;
                     assign FETCH_Instr_andi_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 & FETCH_Instr_raw_i_imm_a2;
                     assign FETCH_Instr_slli_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 << FETCH_Instr_raw_i_imm_a2[5:0];
                     assign FETCH_Instr_srli_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 >> FETCH_Instr_raw_i_imm_a2[5:0];
                     assign FETCH_Instr_srai_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] ? FETCH_Instr_srli_intermediate_rslt_a2 | ((32'b0 - 1) << (32 - FETCH_Instr_raw_i_imm_a2[5:0]) ): FETCH_Instr_srli_intermediate_rslt_a2;
                     assign FETCH_Instr_srl_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 >> L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0];
                     assign FETCH_Instr_sra_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] ? FETCH_Instr_srl_rslt_a2 | ((32'b0 - 1) << (32 - L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0]) ): FETCH_Instr_srl_rslt_a2;
                     assign FETCH_Instr_slti_rslt_a2[31:0]  =  (L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] == FETCH_Instr_raw_i_imm_a2[31]) ? FETCH_Instr_sltiu_rslt_a2 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]};
                     assign FETCH_Instr_sltiu_rslt_a2[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2 < FETCH_Instr_raw_i_imm_a2) ? 1 : 0;
                     assign FETCH_Instr_srai_rslt_a2[31:0]  = FETCH_Instr_srai_intermediate_rslt_a2;
                     assign FETCH_Instr_srli_rslt_a2[31:0]  = FETCH_Instr_srli_intermediate_rslt_a2;
                     assign FETCH_Instr_add_sub_rslt_a2[31:0] = (FETCH_Instr_raw_funct7_a2[5] == 1) ?  L1b_FETCH_Instr_Src[1].L1_reg_value_a2 - L1b_FETCH_Instr_Src[2].L1_reg_value_a2 : L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                     assign FETCH_Instr_add_rslt_a2[31:0]   = FETCH_Instr_add_sub_rslt_a2;
                     assign FETCH_Instr_sub_rslt_a2[31:0]   = FETCH_Instr_add_sub_rslt_a2;
                     assign FETCH_Instr_sll_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 << L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0];
                     assign FETCH_Instr_slt_rslt_a2[31:0]   = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] == L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]) ? FETCH_Instr_sltu_rslt_a2 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]};
                     assign FETCH_Instr_sltu_rslt_a2[31:0]  = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2 < L1b_FETCH_Instr_Src[2].L1_reg_value_a2) ? 1 : 0;
                     assign FETCH_Instr_xor_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                     assign FETCH_Instr_or_rslt_a2[31:0]    = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 | L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                     assign FETCH_Instr_and_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 & L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                     // CSR read instructions have the same result expression. Counting on synthesis to optimize result mux.
                     assign FETCH_Instr_csrrw_rslt_a2[31:0]  = FETCH_Instr_is_csr_instreth_a2 ? {{0{1'b0}},FETCH_Instr_csr_instreth_a2} : FETCH_Instr_is_csr_instret_a2 ? {{0{1'b0}},FETCH_Instr_csr_instret_a2} : FETCH_Instr_is_csr_timeh_a2 ? {{0{1'b0}},FETCH_Instr_csr_timeh_a2} : FETCH_Instr_is_csr_time_a2 ? {{0{1'b0}},FETCH_Instr_csr_time_a2} : FETCH_Instr_is_csr_cycleh_a2 ? {{0{1'b0}},FETCH_Instr_csr_cycleh_a2} : FETCH_Instr_is_csr_cycle_a2 ? {{0{1'b0}},FETCH_Instr_csr_cycle_a2} : 32'bx;
                     assign FETCH_Instr_csrrs_rslt_a2[31:0]  = FETCH_Instr_csrrw_rslt_a2;
                     assign FETCH_Instr_csrrc_rslt_a2[31:0]  = FETCH_Instr_csrrw_rslt_a2;
                     assign FETCH_Instr_csrrwi_rslt_a2[31:0] = FETCH_Instr_csrrw_rslt_a2;
                     assign FETCH_Instr_csrrsi_rslt_a2[31:0] = FETCH_Instr_csrrw_rslt_a2;
                     assign FETCH_Instr_csrrci_rslt_a2[31:0] = FETCH_Instr_csrrw_rslt_a2;
                     
                     // "M" Extension.
                     
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2176 as: m4+ifelse(M4_EXT_M, 1,
                        
                        
                     //_\end_source
                  
                     // "F" Extension.
                     
                     // TODO: Move this under /fpu.
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2206 as: m4+ifelse(M4_EXT_F, 1,
                        
                        
                     //_\end_source
                     
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2280 as: m4+ifelse(M4_EXT_B, 1,
                        
                        
                     //_\end_source
            
               // CSR logic
               // ---------
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1655   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2404 as: m4+riscv_csrs([''](m4_csrs)[''])
                  // TODO: This doesn't maintain alignment. Need an m4+foreach macro.
                  
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1610   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1658 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                     //--------------
                     // CSR CYCLE
                     //--------------
                     //_@1
                        assign FETCH_Instr_is_csr_cycle_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC00;
                     //_@2
                        // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                        // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                        
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1621 as: m4+ifelse(1, 1,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1622   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__22.
                              // hw_wr_mask conditioned by hw_wr.
                              assign FETCH_Instr_csr_cycle_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_cycle_hw_wr_a2}} & FETCH_Instr_csr_cycle_hw_wr_mask_a2;
                              // The CSR value, updated by side-effect writes.
                              assign FETCH_Instr_upd_csr_cycle_a2[31:0] =
                                   (FETCH_Instr_csr_cycle_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycle_hw_wr_value_a2) | (~ FETCH_Instr_csr_cycle_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycle_a2);
                           //_\end_source
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1633 as: m4+ifelse(1, RO,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1636   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__25.
                              // Next value of the CSR.
                              assign FETCH_Instr_csr_cycle_masked_wr_value_a2[31:0] =
                                   FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                              assign FETCH_Instr_csr_cycle_a1[31:0] =
                                   FETCH_Instr_reset_a2 ? 32'b0 :
                                   ! FETCH_Instr_commit_a2
                                          ? FETCH_Instr_upd_csr_cycle_a2 :
                                   FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_cycle_a2
                                          ? FETCH_Instr_csr_cycle_masked_wr_value_a2 | (FETCH_Instr_upd_csr_cycle_a2 & ~ {32{1'b1}}) :
                                   FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_cycle_a2
                                          ? FETCH_Instr_upd_csr_cycle_a2 |   FETCH_Instr_csr_cycle_masked_wr_value_a2 :
                                   FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_cycle_a2
                                          ? FETCH_Instr_upd_csr_cycle_a2 & ~ FETCH_Instr_csr_cycle_masked_wr_value_a2 :
                                   // No CSR instruction update, only h/w side-effects.
                                            FETCH_Instr_upd_csr_cycle_a2;
                           //_\end_source
                           
                        //_\end_source
                  //_\end_source
                  
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1610   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1658 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                     //--------------
                     // CSR CYCLEH
                     //--------------
                     //_@1
                        assign FETCH_Instr_is_csr_cycleh_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC80;
                     //_@2
                        // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                        // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                        
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1621 as: m4+ifelse(1, 1,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1622   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__26.
                              // hw_wr_mask conditioned by hw_wr.
                              assign FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_cycleh_hw_wr_a2}} & FETCH_Instr_csr_cycleh_hw_wr_mask_a2;
                              // The CSR value, updated by side-effect writes.
                              assign FETCH_Instr_upd_csr_cycleh_a2[31:0] =
                                   (FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycleh_hw_wr_value_a2) | (~ FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycleh_a2);
                           //_\end_source
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1633 as: m4+ifelse(1, RO,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1636   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__29.
                              // Next value of the CSR.
                              assign FETCH_Instr_csr_cycleh_masked_wr_value_a2[31:0] =
                                   FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                              assign FETCH_Instr_csr_cycleh_a1[31:0] =
                                   FETCH_Instr_reset_a2 ? 32'b0 :
                                   ! FETCH_Instr_commit_a2
                                          ? FETCH_Instr_upd_csr_cycleh_a2 :
                                   FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_cycleh_a2
                                          ? FETCH_Instr_csr_cycleh_masked_wr_value_a2 | (FETCH_Instr_upd_csr_cycleh_a2 & ~ {32{1'b1}}) :
                                   FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_cycleh_a2
                                          ? FETCH_Instr_upd_csr_cycleh_a2 |   FETCH_Instr_csr_cycleh_masked_wr_value_a2 :
                                   FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_cycleh_a2
                                          ? FETCH_Instr_upd_csr_cycleh_a2 & ~ FETCH_Instr_csr_cycleh_masked_wr_value_a2 :
                                   // No CSR instruction update, only h/w side-effects.
                                            FETCH_Instr_upd_csr_cycleh_a2;
                           //_\end_source
                           
                        //_\end_source
                  //_\end_source
                  
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1610   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1658 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                     //--------------
                     // CSR TIME
                     //--------------
                     //_@1
                        assign FETCH_Instr_is_csr_time_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC01;
                     //_@2
                        // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                        // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                        
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1621 as: m4+ifelse(1, 1,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1622   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__30.
                              // hw_wr_mask conditioned by hw_wr.
                              assign FETCH_Instr_csr_time_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_time_hw_wr_a2}} & FETCH_Instr_csr_time_hw_wr_mask_a2;
                              // The CSR value, updated by side-effect writes.
                              assign FETCH_Instr_upd_csr_time_a2[31:0] =
                                   (FETCH_Instr_csr_time_hw_wr_en_mask_a2 & FETCH_Instr_csr_time_hw_wr_value_a2) | (~ FETCH_Instr_csr_time_hw_wr_en_mask_a2 & FETCH_Instr_csr_time_a2);
                           //_\end_source
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1633 as: m4+ifelse(1, RO,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1636   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__33.
                              // Next value of the CSR.
                              assign FETCH_Instr_csr_time_masked_wr_value_a2[31:0] =
                                   FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                              assign FETCH_Instr_csr_time_a1[31:0] =
                                   FETCH_Instr_reset_a2 ? 32'b0 :
                                   ! FETCH_Instr_commit_a2
                                          ? FETCH_Instr_upd_csr_time_a2 :
                                   FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_time_a2
                                          ? FETCH_Instr_csr_time_masked_wr_value_a2 | (FETCH_Instr_upd_csr_time_a2 & ~ {32{1'b1}}) :
                                   FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_time_a2
                                          ? FETCH_Instr_upd_csr_time_a2 |   FETCH_Instr_csr_time_masked_wr_value_a2 :
                                   FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_time_a2
                                          ? FETCH_Instr_upd_csr_time_a2 & ~ FETCH_Instr_csr_time_masked_wr_value_a2 :
                                   // No CSR instruction update, only h/w side-effects.
                                            FETCH_Instr_upd_csr_time_a2;
                           //_\end_source
                           
                        //_\end_source
                  //_\end_source
                  
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1610   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1658 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                     //--------------
                     // CSR TIMEH
                     //--------------
                     //_@1
                        assign FETCH_Instr_is_csr_timeh_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC81;
                     //_@2
                        // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                        // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                        
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1621 as: m4+ifelse(1, 1,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1622   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__34.
                              // hw_wr_mask conditioned by hw_wr.
                              assign FETCH_Instr_csr_timeh_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_timeh_hw_wr_a2}} & FETCH_Instr_csr_timeh_hw_wr_mask_a2;
                              // The CSR value, updated by side-effect writes.
                              assign FETCH_Instr_upd_csr_timeh_a2[31:0] =
                                   (FETCH_Instr_csr_timeh_hw_wr_en_mask_a2 & FETCH_Instr_csr_timeh_hw_wr_value_a2) | (~ FETCH_Instr_csr_timeh_hw_wr_en_mask_a2 & FETCH_Instr_csr_timeh_a2);
                           //_\end_source
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1633 as: m4+ifelse(1, RO,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1636   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__37.
                              // Next value of the CSR.
                              assign FETCH_Instr_csr_timeh_masked_wr_value_a2[31:0] =
                                   FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                              assign FETCH_Instr_csr_timeh_a1[31:0] =
                                   FETCH_Instr_reset_a2 ? 32'b0 :
                                   ! FETCH_Instr_commit_a2
                                          ? FETCH_Instr_upd_csr_timeh_a2 :
                                   FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_timeh_a2
                                          ? FETCH_Instr_csr_timeh_masked_wr_value_a2 | (FETCH_Instr_upd_csr_timeh_a2 & ~ {32{1'b1}}) :
                                   FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_timeh_a2
                                          ? FETCH_Instr_upd_csr_timeh_a2 |   FETCH_Instr_csr_timeh_masked_wr_value_a2 :
                                   FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_timeh_a2
                                          ? FETCH_Instr_upd_csr_timeh_a2 & ~ FETCH_Instr_csr_timeh_masked_wr_value_a2 :
                                   // No CSR instruction update, only h/w side-effects.
                                            FETCH_Instr_upd_csr_timeh_a2;
                           //_\end_source
                           
                        //_\end_source
                  //_\end_source
                  
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1610   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1658 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                     //--------------
                     // CSR INSTRET
                     //--------------
                     //_@1
                        assign FETCH_Instr_is_csr_instret_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC02;
                     //_@2
                        // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                        // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                        
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1621 as: m4+ifelse(1, 1,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1622   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__38.
                              // hw_wr_mask conditioned by hw_wr.
                              assign FETCH_Instr_csr_instret_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_instret_hw_wr_a2}} & FETCH_Instr_csr_instret_hw_wr_mask_a2;
                              // The CSR value, updated by side-effect writes.
                              assign FETCH_Instr_upd_csr_instret_a2[31:0] =
                                   (FETCH_Instr_csr_instret_hw_wr_en_mask_a2 & FETCH_Instr_csr_instret_hw_wr_value_a2) | (~ FETCH_Instr_csr_instret_hw_wr_en_mask_a2 & FETCH_Instr_csr_instret_a2);
                           //_\end_source
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1633 as: m4+ifelse(1, RO,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1636   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__41.
                              // Next value of the CSR.
                              assign FETCH_Instr_csr_instret_masked_wr_value_a2[31:0] =
                                   FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                              assign FETCH_Instr_csr_instret_a1[31:0] =
                                   FETCH_Instr_reset_a2 ? 32'b0 :
                                   ! FETCH_Instr_commit_a2
                                          ? FETCH_Instr_upd_csr_instret_a2 :
                                   FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_instret_a2
                                          ? FETCH_Instr_csr_instret_masked_wr_value_a2 | (FETCH_Instr_upd_csr_instret_a2 & ~ {32{1'b1}}) :
                                   FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_instret_a2
                                          ? FETCH_Instr_upd_csr_instret_a2 |   FETCH_Instr_csr_instret_masked_wr_value_a2 :
                                   FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_instret_a2
                                          ? FETCH_Instr_upd_csr_instret_a2 & ~ FETCH_Instr_csr_instret_masked_wr_value_a2 :
                                   // No CSR instruction update, only h/w side-effects.
                                            FETCH_Instr_upd_csr_instret_a2;
                           //_\end_source
                           
                        //_\end_source
                  //_\end_source
                  
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1610   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1658 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                     //--------------
                     // CSR INSTRETH
                     //--------------
                     //_@1
                        assign FETCH_Instr_is_csr_instreth_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC82;
                     //_@2
                        // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                        // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                        
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1621 as: m4+ifelse(1, 1,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1622   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__42.
                              // hw_wr_mask conditioned by hw_wr.
                              assign FETCH_Instr_csr_instreth_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_instreth_hw_wr_a2}} & FETCH_Instr_csr_instreth_hw_wr_mask_a2;
                              // The CSR value, updated by side-effect writes.
                              assign FETCH_Instr_upd_csr_instreth_a2[31:0] =
                                   (FETCH_Instr_csr_instreth_hw_wr_en_mask_a2 & FETCH_Instr_csr_instreth_hw_wr_value_a2) | (~ FETCH_Instr_csr_instreth_hw_wr_en_mask_a2 & FETCH_Instr_csr_instreth_a2);
                           //_\end_source
                           
                        //_\end_source
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1633 as: m4+ifelse(1, RO,
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1636   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__45.
                              // Next value of the CSR.
                              assign FETCH_Instr_csr_instreth_masked_wr_value_a2[31:0] =
                                   FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                              assign FETCH_Instr_csr_instreth_a1[31:0] =
                                   FETCH_Instr_reset_a2 ? 32'b0 :
                                   ! FETCH_Instr_commit_a2
                                          ? FETCH_Instr_upd_csr_instreth_a2 :
                                   FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_instreth_a2
                                          ? FETCH_Instr_csr_instreth_masked_wr_value_a2 | (FETCH_Instr_upd_csr_instreth_a2 & ~ {32{1'b1}}) :
                                   FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_instreth_a2
                                          ? FETCH_Instr_upd_csr_instreth_a2 |   FETCH_Instr_csr_instreth_masked_wr_value_a2 :
                                   FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_instreth_a2
                                          ? FETCH_Instr_upd_csr_instreth_a2 & ~ FETCH_Instr_csr_instreth_masked_wr_value_a2 :
                                   // No CSR instruction update, only h/w side-effects.
                                            FETCH_Instr_upd_csr_instreth_a2;
                           //_\end_source
                           
                        //_\end_source
                  //_\end_source
                  
               //_\end_source
               //_@2
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1661   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2406 as: m4+riscv_csr_logic()
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1662 as: m4+ifelse(m4_csrs, [''], [''],
                        //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1663   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__46.
                           // CSR write value for CSR write instructions.
                           assign FETCH_Instr_csr_wr_value_a2[31:0] = FETCH_Instr_raw_funct3_a2[2] ? {27'b0, FETCH_Instr_raw_rs1_a2} : L1b_FETCH_Instr_Src[1].L1_reg_value_a2;
                        //_\end_source
                        
                     //_\end_source
                  
                     // Counter CSR
                     //
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1670 as: m4+ifelse(M4_NO_COUNTER_CSRS, 1,
                        //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1673   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__48.
                           // Count within time unit. This is not reset on writes to time CSR, so time CSR is only accurate to time unit.
                           assign FETCH_Instr_RemainingCyclesWithinTimeUnit_a1[30-1:0] =
                                (FETCH_Instr_reset_a2 || FETCH_Instr_time_unit_expires_a2) ?
                                       30'd999999999 :
                                       FETCH_Instr_RemainingCyclesWithinTimeUnit_a2 - 30'b1;
                           assign FETCH_Instr_time_unit_expires_a2 = !( | FETCH_Instr_RemainingCyclesWithinTimeUnit_a2);  // reaches zero
                                          
                           assign FETCH_Instr_full_csr_cycle_hw_wr_value_a2[63:0]   = {FETCH_Instr_csr_cycleh_a2,   FETCH_Instr_csr_cycle_a2  } + 64'b1;
                           assign FETCH_Instr_full_csr_time_hw_wr_value_a2[63:0]    = {FETCH_Instr_csr_timeh_a2,    FETCH_Instr_csr_time_a2   } + 64'b1;
                           assign FETCH_Instr_full_csr_instret_hw_wr_value_a2[63:0] = {FETCH_Instr_csr_instreth_a2, FETCH_Instr_csr_instret_a2} + 64'b1;
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1684 as: m4+ifelse(M4_EXT_F, 1,
                              
                              
                           //_\end_source
                           // CSR h/w side-effect write signals.
                           assign FETCH_Instr_csr_cycle_hw_wr_a2 = 1'b1;
                           assign FETCH_Instr_csr_cycle_hw_wr_mask_a2[31:0] = {32{1'b1}};
                           assign FETCH_Instr_csr_cycle_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a2[31:0];
                           assign FETCH_Instr_csr_cycleh_hw_wr_a2 = 1'b1;
                           assign FETCH_Instr_csr_cycleh_hw_wr_mask_a2[31:0] = {32{1'b1}};
                           assign FETCH_Instr_csr_cycleh_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a2[63:32];
                           assign FETCH_Instr_csr_time_hw_wr_a2 = FETCH_Instr_time_unit_expires_a2;
                           assign FETCH_Instr_csr_time_hw_wr_mask_a2[31:0] = {32{1'b1}};
                           assign FETCH_Instr_csr_time_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a2[31:0];
                           assign FETCH_Instr_csr_timeh_hw_wr_a2 = FETCH_Instr_time_unit_expires_a2;
                           assign FETCH_Instr_csr_timeh_hw_wr_mask_a2[31:0] = {32{1'b1}};
                           assign FETCH_Instr_csr_timeh_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a2[63:32];
                           assign FETCH_Instr_csr_instret_hw_wr_a2 = FETCH_Instr_commit_a2;
                           assign FETCH_Instr_csr_instret_hw_wr_mask_a2[31:0] = {32{1'b1}};
                           assign FETCH_Instr_csr_instret_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a2[31:0];
                           assign FETCH_Instr_csr_instreth_hw_wr_a2 = FETCH_Instr_commit_a2;
                           assign FETCH_Instr_csr_instreth_hw_wr_mask_a2[31:0] = {32{1'b1}};
                           assign FETCH_Instr_csr_instreth_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a2[63:32];
                           //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1711 as: m4+ifelse(M4_EXT_F, 1,
                              
                              
                           //_\end_source
                        //_\end_source
                        
                     //_\end_source
                     
                     // For multicore CSRs:
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 1728 as: m4+ifelse(m4_eval(M4_NUM_CORES > 1), 1,
                        
                        
                     //_\end_source
                  //_\end_source
                  
                  // Memory inputs.
                  //_?$valid_exe
                     assign FETCH_Instr_unnatural_addr_trap_a2 = (FETCH_Instr_ld_st_word_a2 && (FETCH_Instr_addr_a2[1:0] != 2'b00)) || (FETCH_Instr_ld_st_half_a2 && FETCH_Instr_addr_a2[0]);
                  assign FETCH_Instr_ld_st_cond_a2 = FETCH_Instr_ld_st_a2 && FETCH_Instr_valid_exe_a2;
                  //_?$ld_st_cond
                     assign FETCH_Instr_addr_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + (FETCH_Instr_ld_a2 ? FETCH_Instr_raw_i_imm_a2 : FETCH_Instr_raw_s_imm_a2);
                     
                     // Hardware assumes natural alignment. Otherwise, trap, and handle in s/w (though no s/w provided).
                  assign FETCH_Instr_st_cond_a2 = FETCH_Instr_st_a2 && FETCH_Instr_valid_exe_a2;
                  //_?$st_cond
                     // Provide a value to store, naturally-aligned to memory, that will work regardless of the lower $addr bits.
                     assign FETCH_Instr_st_reg_value_a2[31:0] = 
                                                              L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                     assign FETCH_Instr_st_value_a2[31:0] =
                          FETCH_Instr_ld_st_word_a2 ? FETCH_Instr_st_reg_value_a2 :            // word
                          FETCH_Instr_ld_st_half_a2 ? {2{FETCH_Instr_st_reg_value_a2[15:0]}} : // half
                                        {4{FETCH_Instr_st_reg_value_a2[7:0]}};   // byte
                     assign FETCH_Instr_st_mask_a2[3:0] =
                          FETCH_Instr_ld_st_word_a2 ? 4'hf :                     // word
                          FETCH_Instr_ld_st_half_a2 ? (FETCH_Instr_addr_a2[1] ? 4'hc : 4'h3) : // half
                                        (4'h1 << FETCH_Instr_addr_a2[1:0]);      // byte
            
                  // Swizzle bytes for load result (assuming natural alignment) and pass to /orig_load_inst scope
                  //_?$second_issue_ld
                     //_/orig_load_inst
                        assign FETCH_Instr_OrigLoadInst_spec_ld_cond_a2 = FETCH_Instr_OrigLoadInst_spec_ld_a2;
                        //_?$spec_ld_cond
                           // (Verilator didn't like indexing $ld_value by signal math, so we do these the long way.)
                           assign FETCH_Instr_OrigLoadInst_sign_bit_a2 =
                              ! FETCH_Instr_OrigLoadInst_raw_funct3_a2[2] && (  // Signed && ...
                                 FETCH_Instr_OrigLoadInst_ld_st_word_a2 ? FETCH_Instr_OrigLoadInst_ld_value_a2[31] :
                                 FETCH_Instr_OrigLoadInst_ld_st_half_a2 ? (FETCH_Instr_OrigLoadInst_addr_a2[1] ? FETCH_Instr_OrigLoadInst_ld_value_a2[31] : FETCH_Instr_OrigLoadInst_ld_value_a2[15]) :
                                               ((FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b00) ? FETCH_Instr_OrigLoadInst_ld_value_a2[7] :
                                                (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b01) ? FETCH_Instr_OrigLoadInst_ld_value_a2[15] :
                                                (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b10) ? FETCH_Instr_OrigLoadInst_ld_value_a2[23] :
                                                                        FETCH_Instr_OrigLoadInst_ld_value_a2[31]
                                               )
                              );
                           assign {FETCH_Instr_OrigLoadInst_ld_rslt_a2[31:0], FETCH_Instr_OrigLoadInst_ld_mask_a2[3:0]} =
                                FETCH_Instr_OrigLoadInst_ld_st_word_a2 ? {FETCH_Instr_OrigLoadInst_ld_value_a2, 4'b1111} :
                                FETCH_Instr_OrigLoadInst_ld_st_half_a2 ? {{16{FETCH_Instr_OrigLoadInst_sign_bit_a2}}, FETCH_Instr_OrigLoadInst_addr_a2[1] ? {FETCH_Instr_OrigLoadInst_ld_value_a2[31:16], 4'b1100} :
                                                                           {FETCH_Instr_OrigLoadInst_ld_value_a2[15:0] , 4'b0011}} :
                                              {{24{FETCH_Instr_OrigLoadInst_sign_bit_a2}}, (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b00) ? {FETCH_Instr_OrigLoadInst_ld_value_a2[7:0]  , 4'b0001} :
                                                                (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b01) ? {FETCH_Instr_OrigLoadInst_ld_value_a2[15:8] , 4'b0010} :
                                                                (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b10) ? {FETCH_Instr_OrigLoadInst_ld_value_a2[23:16], 4'b0100} :
                                                                                        {FETCH_Instr_OrigLoadInst_ld_value_a2[31:24], 4'b1000}};
                           `BOGUS_USE(FETCH_Instr_OrigLoadInst_ld_mask_a2) // It's only for formal verification.
                  // ISA-specific trap conditions:
                  // I can't see in the spec which of these is to commit results. I've made choices that make riscv-formal happy.
                  assign FETCH_Instr_non_aborting_isa_trap_a2 = (FETCH_Instr_branch_a2 && FETCH_Instr_taken_a2 && FETCH_Instr_misaligned_pc_a2) ||
                                           (FETCH_Instr_jump_a2 && FETCH_Instr_misaligned_jump_target_a2) ||
                                           (FETCH_Instr_indirect_jump_a2 && FETCH_Instr_misaligned_indirect_jump_target_a2);
                  assign FETCH_Instr_aborting_isa_trap_a2 =     (FETCH_Instr_ld_st_a2 && FETCH_Instr_unnatural_addr_trap_a2) ||
                                           FETCH_Instr_csr_trap_a2;
                  
               //_@2
                  // Mux the correct result.
                  //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 1750   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2465 as: m4+riscv_rslt_mux_expr()
                     // in case of second issue, the results are pulled out of the /orig_inst or /load_inst scope. 
                     // no alignment is needed as the rslt mux and the long latency results both appear in the same pipestage.
                  
                     // in the case of second isssue for multiplication with ALTOPS enabled (or running formal checks for M extension), 
                     // the module gives out the result in two cycles but we explicitly flop the $mul_rslt 
                     // (by alignment with 3+NON_PIPELINED_BUBBLES to augment the 5 cycle behavior of the mul operation
                  
                     assign FETCH_Instr_rslt_a2[31:0] =
                           FETCH_Instr_second_issue_ld_a2 ? FETCH_Instr_OrigLoadInst_ld_rslt_a2 : 
                           
                           
                            
                           
                            
                           
                           
                           
                           32'b0 |
                         ({32{FETCH_Instr_is_lui_instr_a2}} & FETCH_Instr_lui_rslt_a2) |
                         ({32{FETCH_Instr_is_auipc_instr_a2}} & FETCH_Instr_auipc_rslt_a2) |
                         ({32{FETCH_Instr_is_jal_instr_a2}} & FETCH_Instr_jal_rslt_a2) |
                         ({32{FETCH_Instr_is_jalr_instr_a2}} & FETCH_Instr_jalr_rslt_a2) |
                         ({32{FETCH_Instr_is_lb_instr_a2}} & FETCH_Instr_lb_rslt_a2) |
                         ({32{FETCH_Instr_is_lh_instr_a2}} & FETCH_Instr_lh_rslt_a2) |
                         ({32{FETCH_Instr_is_lw_instr_a2}} & FETCH_Instr_lw_rslt_a2) |
                         ({32{FETCH_Instr_is_lbu_instr_a2}} & FETCH_Instr_lbu_rslt_a2) |
                         ({32{FETCH_Instr_is_lhu_instr_a2}} & FETCH_Instr_lhu_rslt_a2) |
                         ({32{FETCH_Instr_is_addi_instr_a2}} & FETCH_Instr_addi_rslt_a2) |
                         ({32{FETCH_Instr_is_slti_instr_a2}} & FETCH_Instr_slti_rslt_a2) |
                         ({32{FETCH_Instr_is_sltiu_instr_a2}} & FETCH_Instr_sltiu_rslt_a2) |
                         ({32{FETCH_Instr_is_xori_instr_a2}} & FETCH_Instr_xori_rslt_a2) |
                         ({32{FETCH_Instr_is_ori_instr_a2}} & FETCH_Instr_ori_rslt_a2) |
                         ({32{FETCH_Instr_is_andi_instr_a2}} & FETCH_Instr_andi_rslt_a2) |
                         ({32{FETCH_Instr_is_slli_instr_a2}} & FETCH_Instr_slli_rslt_a2) |
                         ({32{FETCH_Instr_is_srli_instr_a2}} & FETCH_Instr_srli_rslt_a2) |
                         ({32{FETCH_Instr_is_srai_instr_a2}} & FETCH_Instr_srai_rslt_a2) |
                         ({32{FETCH_Instr_is_add_instr_a2}} & FETCH_Instr_add_rslt_a2) |
                         ({32{FETCH_Instr_is_sub_instr_a2}} & FETCH_Instr_sub_rslt_a2) |
                         ({32{FETCH_Instr_is_sll_instr_a2}} & FETCH_Instr_sll_rslt_a2) |
                         ({32{FETCH_Instr_is_slt_instr_a2}} & FETCH_Instr_slt_rslt_a2) |
                         ({32{FETCH_Instr_is_sltu_instr_a2}} & FETCH_Instr_sltu_rslt_a2) |
                         ({32{FETCH_Instr_is_xor_instr_a2}} & FETCH_Instr_xor_rslt_a2) |
                         ({32{FETCH_Instr_is_srl_instr_a2}} & FETCH_Instr_srl_rslt_a2) |
                         ({32{FETCH_Instr_is_sra_instr_a2}} & FETCH_Instr_sra_rslt_a2) |
                         ({32{FETCH_Instr_is_or_instr_a2}} & FETCH_Instr_or_rslt_a2) |
                         ({32{FETCH_Instr_is_and_instr_a2}} & FETCH_Instr_and_rslt_a2) |
                         ({32{FETCH_Instr_is_csrrw_instr_a2}} & FETCH_Instr_csrrw_rslt_a2) |
                         ({32{FETCH_Instr_is_csrrs_instr_a2}} & FETCH_Instr_csrrs_rslt_a2) |
                         ({32{FETCH_Instr_is_csrrc_instr_a2}} & FETCH_Instr_csrrc_rslt_a2) |
                         ({32{FETCH_Instr_is_csrrwi_instr_a2}} & FETCH_Instr_csrrwi_rslt_a2) |
                         ({32{FETCH_Instr_is_csrrsi_instr_a2}} & FETCH_Instr_csrrsi_rslt_a2) |
                         ({32{FETCH_Instr_is_csrrci_instr_a2}} & FETCH_Instr_csrrci_rslt_a2);
                     
                  //_\end_source
            //_\end_source
            
            //_@1
               assign FETCH_Instr_pred_taken_branch_a1 = FETCH_Instr_pred_taken_a1 && FETCH_Instr_branch_a1;
            //_@2
   
               // =======
               // Control
               // =======
               
               // A version of PC we can pull through $ANYs.
               assign FETCH_Instr_pc_a2[31:2] = FETCH_Instr_Pc_a2[31:2];
               `BOGUS_USE(FETCH_Instr_pc_a2)
               
               
               // Execute stage redirect conditions.
               assign FETCH_Instr_non_pipelined_a2 = FETCH_Instr_div_mul_a2  ;
               assign FETCH_Instr_replay_trap_a2 = 1'b0;
               assign FETCH_Instr_aborting_trap_a2 = (FETCH_Instr_replay_trap_a2 || (FETCH_Instr_valid_decode_a2 && FETCH_Instr_illegal_a2) || FETCH_Instr_aborting_isa_trap_a2);
               assign FETCH_Instr_non_aborting_trap_a2 = FETCH_Instr_non_aborting_isa_trap_a2;
               assign FETCH_Instr_mispred_branch_a2 = FETCH_Instr_branch_a2 && ! (FETCH_Instr_conditional_branch_a2 && (FETCH_Instr_taken_a2 == FETCH_Instr_pred_taken_a2));
               //_?$valid_decode_branch
                  assign FETCH_Instr_branch_redir_pc_a2[31:2] =
                     // If fallthrough predictor, branch mispred always redirects taken, otherwise PC+1 for not-taken.
                     (! FETCH_Instr_taken_a2) ? FETCH_Instr_Pc_a2 + 30'b1 :
                     FETCH_Instr_branch_target_a2;
   
               assign FETCH_Instr_trap_target_a2[31:2] = FETCH_Instr_replay_trap_a2 ? FETCH_Instr_Pc_a2 : {30{1'b1}};  // TODO: What should this be? Using ones to terminate test for now.
               
               // Determine whether the instruction should commit it's result.
               //
               // Abort: Instruction triggers a condition causing a no-commit.
               // Commit: Ultimate decision to commit results of this instruction, considering aborts and
               //         prior-instruction redirects (good-path)
               //
               // Treatment of loads:
               //    Loads will commit. They write a garbage value and "pending" to the register file.
               //    Returning loads clobber an instruction. This instruction is $abort'ed (as is the
               //    returning load, since they are one in the same). Returning load must explicitly
               //    write results.
               //
               
               assign FETCH_Instr_abort_a2 = 1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2 || FETCH_Instr_aborting_trap_a2;  // Note that register bypass logic requires that abort conditions also redirect.
               // $commit = m4_prev_instr_valid_through(M4_MAX_REDIRECT_BUBBLES + 1), where +1 accounts for this
               // instruction's redirects. However, to meet timing, we consider this instruction separately, so,
               // commit if valid as of the latest redirect from prior instructions and not abort of this instruction.
               
               // Normal case:
               assign FETCH_Instr_good_path_a2 = (! FETCH_Instr_reset_a2 && FETCH_Instr_next_good_path_mask_a0[3]);
               assign FETCH_Instr_commit_a2 = FETCH_Instr_good_path_a2 && ! FETCH_Instr_abort_a2;
               
               
               
               
               
               
               // Conditions that commit results.
               assign FETCH_Instr_valid_dest_reg_valid_a2 = (FETCH_Instr_dest_reg_valid_a2 && FETCH_Instr_commit_a2) || (FETCH_Instr_second_issue_a2  );
   
               
               
                  
               
               assign FETCH_Instr_valid_ld_a2 = FETCH_Instr_ld_a2 && FETCH_Instr_commit_a2;
               assign FETCH_Instr_valid_st_a2 = FETCH_Instr_st_a2 && FETCH_Instr_commit_a2;
   
      //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 2977   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3747 as: m4+fixed_latency_fake_memory(/top, 0)
         // This macro assumes little-endian.
         
         //_|fetch
            //_/instr
               // ====
               // Load
               // ====
               //_@3
                  /* DMEM_STYLE: EXTERN */
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 2987 as: m4+ifelse(M4_DMEM_STYLE, STUBBED,
                     
                     //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 90 as: m4+ifelse.
                        
                        //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 90 as: m4+ifelse.
                           //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3021   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__54.
                              assign dmem_addrb = FETCH_Instr_addr_a3;
                              assign dmem_enb   = !FETCH_Instr_valid_ld_a3;  // Active low enable
                              assign dmem_addra = FETCH_Instr_addr_a3;
                              assign dmem_dina  = FETCH_Instr_st_value_a3;
                              assign dmem_dinb  = 32'b0;
                              assign dmem_wea   = {4{FETCH_Instr_valid_st_a3}} & FETCH_Instr_st_mask_a3;
                              assign dmem_web   = 4'b0;
                              assign dmem_wea0  = !(|dmem_wea); // Active low write
                              assign dmem_ena   = !FETCH_Instr_valid_st_a3;  // Active low enable
                              assign FETCH_Instr_ld_data_a4[31:0]  = dmem_doutb;
                           //_\end_source
                           
                        //_\end_source
                     //_\end_source
                  //_\end_source
         // Return loads in |mem pipeline. We just hook up the |mem pipeline to the |fetch pipeline w/ the
         // right alignment.
         //_|mem
            //_/data
               // This becomes a one-liner once $ANY acts on subscopes.
               //_@3
                  assign {MEM_Data_addr_a3[1:0], MEM_Data_dest_reg_a3[4:0], MEM_Data_ld_st_half_a3, MEM_Data_ld_st_word_a3, MEM_Data_pc_a3[31:2], MEM_Data_raw_funct3_a3[2], MEM_Data_spec_ld_a3, MEM_Data_valid_ld_a3} = {FETCH_Instr_addr_a3[1:0], FETCH_Instr_dest_reg_a3, FETCH_Instr_ld_st_half_a3, FETCH_Instr_ld_st_word_a3, FETCH_Instr_pc_a3, FETCH_Instr_raw_funct3_a3[2], FETCH_Instr_spec_ld_a3, FETCH_Instr_valid_ld_a3};
                  for (src = 1; src <= 2; src=src+1) begin : L1_MEM_Data_Src wire L1_dummy_a3; reg  L1_dummy_a4; //_/src
                     assign {L1_dummy_a3} = {L1c_FETCH_Instr_Src[src].L1_dummy_a3}; end
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3070 as: m4+ifelse(M4_EXT_F, 1,
                     
                     
                  //_\end_source
               // For consistency with other memories, assign $ld_value in @M4_MEM_WR_STAGE+1. 
               //_@4
                  assign MEM_Data_ld_value_a4[31:0] = FETCH_Instr_ld_data_a4;
      //_\end_source
      //_|fetch
         //_/instr
            // =========
            // Reg Write
            // =========
            //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3821   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3753 as: m4+rf_wr(/regs, M4_REGS_RANGE, /instr$valid_dest_reg_valid, /instr$dest_reg, /instr$rslt, /instr$reg_wr_pending)
               /* verilator lint_save */
               /* verilator lint_on WIDTH */
               //_@3
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3825 as: m4+ifelse(M4_RF_STYLE, STUBBED,
                     //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3830   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__58.
                        // Reg Write (Floating Point Register)
                        /*SV_plus*/
                           always @ (posedge clk) begin
                              if (FETCH_Instr_valid_dest_reg_valid_a3)
                                 FETCH_Instr_Regs_value_a3[FETCH_Instr_dest_reg_a3][31:0] <= FETCH_Instr_rslt_a3;
                           end
                     //_\end_source
                     
                  //_\end_source
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3838 as: m4+ifelse(M4_PENDING_ENABLED, 1,
                     //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 3839   // Instantiated from /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv, 89 as: m4+ANONYMOUS__59.
                        // Write $pending along with $value, but coded differently because it must be reset.
                        for (regs = 1; regs <= 31; regs=regs+1) begin : L1_FETCH_Instr_Regs //_/regs
                           assign FETCH_Instr_Regs_pending_a2[regs] = ! FETCH_Instr_reset_a3 && (((regs == FETCH_Instr_dest_reg_a3) && FETCH_Instr_valid_dest_reg_valid_a3) ? FETCH_Instr_reg_wr_pending_a3 : FETCH_Instr_Regs_pending_a3[regs]); end
                     //_\end_source
                     
                  //_\end_source
               /* verilator lint_restore */
            //_\end_source
   
            // ======
            // FPU RF
            // ======
            //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 3758 as: m4+ifelse(M4_EXT_F, 1,
               
               
            //_\end_source
   
            //_@3
               `BOGUS_USE(L1_FETCH_Instr_OrigInst_Src[2].L1_dummy_a3) // To pull $dummy through $ANY expressions, avoiding empty expressions.
   
            // TODO. Seperate the $rslt and $reg_wr_pending committed to both "int" and "fpu" regs.
   //_\end_source
   //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 5302   // Instantiated from warpv_core.tlv, 123 as: m4+cpu_viz(|fetch, "#7AD7F0")
      /* CPU_VIZ HERE */
      
      
      
      
      //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 4302   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5308 as: m4+m4_viz_logic_macro_name()
         // Code that supports 
         //_|fetch
            //_@3
               //_/instr
                  // A type-independent immediate value, for debug. (For R-type, funct7 is used as immediate).
                  assign FETCH_Instr_imm_value_a3[31:0] =
                       ({32{FETCH_Instr_is_i_type_a3}} & FETCH_Instr_raw_i_imm_a3) |
                       ({32{FETCH_Instr_is_r_type_a3}} & {25'b0, FETCH_Instr_raw_funct7_a3}) |
                       ({32{FETCH_Instr_is_s_type_a3}} & FETCH_Instr_raw_s_imm_a3) |
                       ({32{FETCH_Instr_is_b_type_a3}} & FETCH_Instr_raw_b_imm_a3) |
                       ({32{FETCH_Instr_is_u_type_a3}} & FETCH_Instr_raw_u_imm_a3) |
                       ({32{FETCH_Instr_is_j_type_a3}} & FETCH_Instr_raw_j_imm_a3);
                  assign FETCH_Instr_imm_valid_a3 = FETCH_Instr_is_i_type_a3 || FETCH_Instr_is_r_type_a3 || FETCH_Instr_is_s_type_a3 || FETCH_Instr_is_b_type_a3 || FETCH_Instr_is_u_type_a3 || FETCH_Instr_is_j_type_a3;
      //_\end_source
      //_|fetch
         //_@3
            //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 5292   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5311 as: m4+layout_viz(['left: 0, top: 0, width: 451, height: 251'], "#7AD7F0")
               /* Viz omitted here */






                     
               //////// VIZUALIZING THE MAIN CPU //////////////
            //_\end_source
            
            //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 4320   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5313 as: m4+instruction_in_memory.
               for (instr_mem = 0; instr_mem <= 10; instr_mem=instr_mem+1) begin : L1_FETCH_InstrMem //_/instr_mem
                  /* Viz omitted here */














































































                  end
                      
                      
               
            //_\end_source
               
            //_/instr
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 4828   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5316 as: m4+instruction(['left: 10, top: 0'])
                  //_?$valid_decode
                     // For debug.
                     assign FETCH_Instr_mnemonic_a3[10*8-1:0] = FETCH_Instr_is_lui_instr_a3 ? "LUI       " : FETCH_Instr_is_auipc_instr_a3 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a3 ? "JAL       " : FETCH_Instr_is_jalr_instr_a3 ? "JALR      " : FETCH_Instr_is_beq_instr_a3 ? "BEQ       " : FETCH_Instr_is_bne_instr_a3 ? "BNE       " : FETCH_Instr_is_blt_instr_a3 ? "BLT       " : FETCH_Instr_is_bge_instr_a3 ? "BGE       " : FETCH_Instr_is_bltu_instr_a3 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a3 ? "BGEU      " : FETCH_Instr_is_lb_instr_a3 ? "LB        " : FETCH_Instr_is_lh_instr_a3 ? "LH        " : FETCH_Instr_is_lw_instr_a3 ? "LW        " : FETCH_Instr_is_lbu_instr_a3 ? "LBU       " : FETCH_Instr_is_lhu_instr_a3 ? "LHU       " : FETCH_Instr_is_sb_instr_a3 ? "SB        " : FETCH_Instr_is_sh_instr_a3 ? "SH        " : FETCH_Instr_is_sw_instr_a3 ? "SW        " : FETCH_Instr_is_addi_instr_a3 ? "ADDI      " : FETCH_Instr_is_slti_instr_a3 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a3 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a3 ? "XORI      " : FETCH_Instr_is_ori_instr_a3 ? "ORI       " : FETCH_Instr_is_andi_instr_a3 ? "ANDI      " : FETCH_Instr_is_slli_instr_a3 ? "SLLI      " : FETCH_Instr_is_srli_instr_a3 ? "SRLI      " : FETCH_Instr_is_srai_instr_a3 ? "SRAI      " : FETCH_Instr_is_add_instr_a3 ? "ADD       " : FETCH_Instr_is_sub_instr_a3 ? "SUB       " : FETCH_Instr_is_sll_instr_a3 ? "SLL       " : FETCH_Instr_is_slt_instr_a3 ? "SLT       " : FETCH_Instr_is_sltu_instr_a3 ? "SLTU      " : FETCH_Instr_is_xor_instr_a3 ? "XOR       " : FETCH_Instr_is_srl_instr_a3 ? "SRL       " : FETCH_Instr_is_sra_instr_a3 ? "SRA       " : FETCH_Instr_is_or_instr_a3 ? "OR        " : FETCH_Instr_is_and_instr_a3 ? "AND       " : FETCH_Instr_is_csrrw_instr_a3 ? "CSRRW     " : FETCH_Instr_is_csrrs_instr_a3 ? "CSRRS     " : FETCH_Instr_is_csrrc_instr_a3 ? "CSRRC     " : FETCH_Instr_is_csrrwi_instr_a3 ? "CSRRWI    " : FETCH_Instr_is_csrrsi_instr_a3 ? "CSRRSI    " : FETCH_Instr_is_csrrci_instr_a3 ? "CSRRCI    " :  "ILLEGAL   ";
                     `BOGUS_USE(FETCH_Instr_mnemonic_a3)
                  /* Viz omitted here */

































































































































































































































































































































                  
               //_\end_source
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 4419   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5317 as: m4+registers(/instr, int, Int RF, , 2, ['left: 350 + 605, top: 10'])
                  // /regs or /fpu_regs
                  for (src = 1; src <= 2; src=src+1) begin : L1d_FETCH_Instr_Src //_/src
                     // There is an issue (#406) with \viz code indexing causing signals to be packed, and if a packed value
                     // has different fields on different clocks, Verilator throws warnings.
                     // These are unconditioned versions of the problematic signals.
                     assign FETCH_Instr_Src_unconditioned_reg_a3[src][4:0] = L1_FETCH_Instr_Src[src].L1_reg_a3;
                     assign FETCH_Instr_Src_unconditioned_is_reg_a3[src] = L1_FETCH_Instr_Src[src].L1_is_reg_a3;
                     assign FETCH_Instr_Src_unconditioned_reg_value_a3[src][31:0] = L1b_FETCH_Instr_Src[src].L1_reg_value_a3; end
                  for (regs = 1; regs <= 31; regs=regs+1) begin : L1b_FETCH_Instr_Regs //_/regs
                     /* Viz omitted here */






























































                     end
               //_\end_source
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 4799   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5318 as: m4+register_csr(/regcsr, ['left: 103 + 605, top: 190'])
                  //_/regcsr
                     /* Viz omitted here */

























               //_\end_source
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 4494   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5319 as: m4+pipeline_control_viz(/pipe_ctrl, ['left: 103 + 605, top: 265 + 18 * m4_num_csrs, width: 220, height: 330'])
                  assign FETCH_Instr_first_issue_a3 = FETCH_Instr_valid_ld_a3 || FETCH_Instr_non_pipelined_a3;
                  //_/pipe_ctrl
                     /* Viz omitted here */













                     //_/logic_diagram
                        /* Viz omitted here */



































































































                     //_/waterfall
                        /* Viz omitted here */













                        for (pipe_ctrl_instr = 0; pipe_ctrl_instr <= 6; pipe_ctrl_instr=pipe_ctrl_instr+1) begin : L1_FETCH_Instr_PipeCtrl_Waterfall_PipeCtrlInstr //_/pipe_ctrl_instr  // Zero on the bottom. See this.getInstrIndex().
                           /* Viz omitted here */












































                           for (pipe_ctrl_stage = 0; pipe_ctrl_stage <= 3; pipe_ctrl_stage=pipe_ctrl_stage+1) begin : L2_PipeCtrlStage //_/pipe_ctrl_stage
                              /* Viz omitted here */


























































































































                              end end
               //_\end_source
               //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5320 as: m4+ifelse(M4_EXT_F, 1,
                  
                  
               //_\end_source
               //_\source /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv 5157   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5325 as: m4+memory_viz(/bank[m4_eval(M4_ADDRS_PER_WORD-1):0] , /mem[M4_DATA_MEM_WORDS_RANGE], ['left: 10 + (550 + 605) -10 + m4_ifelse(M4_EXT_F, 1, ['M4_VIZ_MEM_LEFT_ADJUST'], 0), top: 10'])
                  //_\source /raw.githubusercontent.com/stevehoover/tlvlib/db48b4c22c4846c900b3fa307e87d9744424d916/fundamentalslib.tlv 88   // Instantiated from /raw.githubusercontent.com/ALI112000/warpv/1d9674ce50e970dbbe0d01d29e10fe2cba86c7fe/warpv.tlv, 5158 as: m4+ifelse(M4_DMEM_STYLE, ARRAY,
                     
                     
                  //_\end_source
               //_\end_source
      
      
      
      
   endgenerate //_\end_source
//_\SV
   endmodule
